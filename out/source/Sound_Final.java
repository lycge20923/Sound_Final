/* autogenerated by Processing revision 1293 on 2023-12-22 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import oscP5.*;
import netP5.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Sound_Final extends PApplet {




OscP5 oscp5;

public void oscEvent(OscMessage myOscMessage) {
  if(myOscMessage.checkAddrPattern("/duck") == true) {
    int value = myOscMessage.get(0).intValue();
    if(value == 1) {
      heart.HeartChange(State.red);
    }
    else if(value == 2) {
      heart.HeartChange(State.blue);
    }
  }
}

Heart heart; // Heart 物件 (控制 redHeart)
enum State {
  red, blue
}

Platform platform; // 平台管控
Arrow arrow;

float[] rectPosition;

boolean leftKeyPressed = false;
boolean rightKeyPressed = false;
boolean upKeyPressed = false;
boolean downKeyPressed = false;

public void setup() {
  oscp5 = new OscP5(this, 9999);
  // 背景
  /* size commented out by preprocessor */;
  background(0);
  
  // 白框位址、大小 [左上x, 左上y, 寬, 高]
  rectPosition = new float[]{100, 100, width-200, height-200};
  
  heart = new Heart();
  platform = new Platform(new float[]{rectPosition[0], rectPosition[0] + rectPosition[2], rectPosition[1], rectPosition[1] + rectPosition[3]});
  arrow = new Arrow();
}

static int i = 0;

public void draw() {
  background(0);
  
  heart.draw();
  platform.draw(heart);

  if(i % 60 == 0) platform.create(rectPosition[0] + rectPosition[2], rectPosition[1] + rectPosition[3] - 100, -2, 50);
  if(i % 60 == 0) platform.create(rectPosition[0] - 50, rectPosition[1] + rectPosition[3] - 200, 2, 50);
  i++;

  arrow.draw();
  if (frameCount % 50 == 0) arrow.create(0, 0, 2, 3, 1, 50, PApplet.parseInt(random(4)));
  
  // 白框(設定填充色為透明，邊框色為白色)
  fill(color(255, 255, 255, 0));
  stroke(255);
  strokeWeight(5); // 邊框粗細
  // 繪製一個矩形，左上角座標為 (0, 1)，寬度為 2，高度為 3
  rect(rectPosition[0], rectPosition[1], rectPosition[2], rectPosition[3]);
}

public void keyPressed() {
  if (keyCode == LEFT) {
    leftKeyPressed = true;
  }else if (keyCode == RIGHT) {
    rightKeyPressed = true;
  }else if (keyCode == UP) {
    upKeyPressed = true;
  }else if (keyCode == DOWN) {
    downKeyPressed = true;
  }else {
    if(key == 'r') {
      heart.HeartChange(State.red);
    }
    if(key == 'b') {
      heart.HeartChange(State.blue);    
    }
    int time = 10;
    // press 1~9
    heart.move(PApplet.parseInt(key) - '0', time);
  }
}

public void keyReleased() {
  if (keyCode == LEFT) {
    leftKeyPressed = false;
  }else if (keyCode == RIGHT) {
    rightKeyPressed = false;
  }else if (keyCode == UP) {
    upKeyPressed = false;
  }else if (keyCode == DOWN) {
    downKeyPressed = false;
  }
}

class Heart {
  float heartSize = 20;
  float heartX;
  float heartY;
  float speed = 3;
  
  // 紅心
  // 當前移動方向與時間
  int direction;
  int time;
  
  // 藍心
  // 重力大小, 跳躍初速度
  boolean jumping = true;
  float gravity = 0.4f;
  float initial_velocity = -9;
  float velocity = 0;
  float pre_heartY;
  
  // 邊界判斷 [x_min, x_max, y_min, y_max]
  float[] boundary = new float[4];
  
  PImage redHeart;
  PImage blueHeart;
  PImage currHeart;
  State state = State.red;
  
  Heart() {
    this.heartX = 100 + (width-200) / 2;
    this.heartY = 100 + (height-200) / 2;
    
    //redHeart = loadImage("https://upload.wikimedia.org/wikipedia/commons/a/a5/Undertale.png");
    this.redHeart = loadImage("./images/red_heart.png");
    this.redHeart.resize(PApplet.parseInt(this.heartSize), 0);
    
    this.blueHeart = loadImage("./images/blue_heart.png");
    this.blueHeart.resize(PApplet.parseInt(this.heartSize), 0);
    this.pre_heartY = this.heartY;
    
    this.currHeart = this.redHeart;
    
    this.boundary = new float[]{rectPosition[0] + this.heartSize / 2 + 3,
                                rectPosition[0] + rectPosition[2] - this.heartSize / 2 - 2,
                                rectPosition[1] + this.heartSize / 2 + 3,
                                rectPosition[1] + rectPosition[3] - this.heartSize / 2 - 2};
  }

  // 邊界檢查
  public void boundaryCheck() {
    if (this.heartX < this.boundary[0]) {
      this.heartX = this.boundary[0];
    }
    if (this.heartX > this.boundary[1]) {
      this.heartX = this.boundary[1];
    }
    if (this.heartY < this.boundary[2]) {
      this.heartY = this.boundary[2];
      this.velocity = 0;
    }
    if (this.heartY > this.boundary[3]) {
      this.heartY = this.boundary[3];
    }
  }


  // 紅心移動 ----------------------------------------------
  // 設定移動方向與時間
  // 依照數字鍵方向
  // 7 8 9 ↖ ↑ ↗
  // 4 5 6 ←   →
  // 1 2 3 ↙ ↓ ↘
  public void move(int dir, int t) {
    this.direction = dir;
    this.time = t;
  }

  // 根據當前設定的方向與時間移動
  public void heartMoving() {
    if (this.time <= 0) return;
    this.time -= 1;

    if (this.direction == 1 || this.direction == 4 || this.direction == 7) {
      this.heartX -= this.speed;
    }
    if (this.direction == 3 || this.direction == 6 || this.direction == 9) {
      this.heartX += this.speed;
    }
    if (this.direction == 7 || this.direction == 8 || this.direction == 9) {
      this.heartY -= this.speed;
    }
    if (this.direction == 1 || this.direction == 2 || this.direction == 3) {
      this.heartY += this.speed;
    }
  }

  // 手動移動
  public void manualMoving() {
    if (leftKeyPressed) {
      this.heartX -= this.speed;
    }
    if (rightKeyPressed) {
      this.heartX += this.speed;
    }
    if (upKeyPressed) {
      this.heartY -= this.speed;
    }
    if (downKeyPressed) {
      this.heartY += this.speed;
    }
  }
  // 紅心移動 ----------------------------------------------

  // 藍心移動 ----------------------------------------------
  public void GravityWorking() {
    if (this.heartY < this.boundary[3]) {
      this.heartY += this.velocity;
      this.velocity += this.gravity;
    }
    else {
      this.velocity = 0;
      this.jumping = false;
    }
    
  }
  
  public void manualJumping() {
    if (leftKeyPressed) {
      this.heartX -= this.speed;
    }
    if (rightKeyPressed) {
      this.heartX += this.speed;
    }
    if (upKeyPressed) {
      if(this.jumping == false){
        this.heartY -= 1;
        this.jumping = true;
        this.velocity = this.initial_velocity;
      }
    }
    else {
      if(this.jumping == true && this.velocity < -1.5f) {
        this.velocity = -1.5f;
      }
    }
    if (downKeyPressed) {
      this.heartY += this.speed;
    }
  }
  // 藍心移動 ----------------------------------------------
  
  // 愛心切換
  public void HeartChange(State s) {
    this.state = s;
    if (this.state == State.red){
      println("Change heart to Red");
      this.currHeart = this.redHeart;
    } else if (this.state == State.blue) {
      println("Change heart to Blue");
      this.currHeart = this.blueHeart;
      this.velocity = 0;
    }
  }
  public void HeartBehavior() {
    if (this.state == State.red){
      manualMoving();
      heartMoving();
    } else if (this.state == State.blue) {
      GravityWorking();
      manualJumping();
    }
  }

  // 繪製愛心
  public void draw() {
    imageMode(CENTER);
    image(this.currHeart, this.heartX, this.heartY);
    HeartBehavior();
    boundaryCheck();
  }
}
class Arrow {
    ArrayList<arr> arrows = new ArrayList<arr>();

    public void create(float x, float y, float angle, float speed, float size, float dist, int side) {
        PVector outsidePoint = createOutsidePoint(rectPosition, dist, side); //指定起始：x: (rectPosition[0] - d , rectPosition[0] + rectPosition[2] + d), y: (rectPosition[1] - d , rectPosition[1] + rectPosition[3] + d)  
        arr arrow = new arr(outsidePoint.x, outsidePoint.y, calculateAngle(outsidePoint, rectPosition), speed, size); //(起始x, 起始 y , 角度, 速度, 大小）
        arrows.add(arrow);
    }

    public void draw(){
        for (int i = arrows.size() - 1; i >= 0; i--) {
            arr arrow = arrows.get(i);
            arrow.update();
            arrow.display();

            // 箭飛出邊界刪除
            if (arrow.isOutOfBounds()) {
            arrows.remove(i);
            }
        }
    }

    // 生成方框外的座標
    public PVector createOutsidePoint(float[] rectPosition, float dist, int side) {
        switch (side) {
            case 0:
                return new PVector(random(rectPosition[0], rectPosition[0]+ rectPosition[2]), rectPosition[1] - dist);
            case 1:
                return new PVector(rectPosition[0]+ rectPosition[2] + dist, random(rectPosition[1], rectPosition[1]+ rectPosition[3]));
            case 2:
                return new PVector(random(rectPosition[0], rectPosition[0]+ rectPosition[2]), rectPosition[1]+ rectPosition[3]+ dist);
            case 3:
                return new PVector(rectPosition[0] - dist, random(rectPosition[1], rectPosition[1]+ rectPosition[3]));
            default:
                return new PVector(0, 0);
        }
    }

    // 計算箭往方框的角度
    public float calculateAngle(PVector arrowPos, float[] rectPosition) {
        return atan2(rectPosition[1]+ rectPosition[3] / 2 - arrowPos.y, rectPosition[0]+ rectPosition[2] / 2 - arrowPos.x);
    }

}

class arr{
    float x, y, angle, speed, size, bodyLength, xSpeed, ySpeed, r;
    PImage image;

    arr(float x, float y, float angle, float speed, float size) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.speed = speed;
        this.size = size;
        this.image = loadImage("images/spear.png");
    }
  
    public void update() {
        this.speed += 0.2f;
        this.xSpeed = speed * cos(angle);
        this.ySpeed = speed * sin(angle);
        this.x += this.xSpeed;
        this.y += this.ySpeed;
    }

    public void display() {
        pushMatrix();
        translate(x, y);
        rotate(angle);
        scale(size);
        imageMode(CENTER);
        image(image, 0, 0);
        popMatrix();
    }
    
    // 超出邊界刪除
    public boolean isOutOfBounds() {
        return x < 0 || x > width || y < 0 || y > height;
    } 
 
}


  
class Platform {
    ArrayList<plat> plats = new ArrayList<plat>();
    // 邊界判斷 [x_min, x_max, y_min, y_max]
    float[] boundary = new float[4];
    float flex = 4;

    Platform(float[] boundary) {
        this.boundary = boundary;
    }

    public void create(float x, float y, float width, float speed){
        plat p = new plat(x, y, width, speed);
        this.plats.add(p);
    }
    
    public void draw(Heart heart) {
        ArrayList<Integer> to_be_remove = new ArrayList<Integer>();
        boolean jumping_flag = true;
        float ori_heart_speed = heart.speed;
        for(int i=this.plats.size()-1; i>=0; i--){
            plat p = this.plats.get(i);
            p.display(this.boundary);

            // heart on the platform
            if(p.x - flex <= heart.heartX && heart.heartX <= p.x + p.width + flex && heart.heartY + heart.heartSize/2 <= p.y && heart.heartY + heart.heartSize/2 + heart.velocity >= p.y) {
                heart.heartX += p.speed;
                heart.speed = 2.5f;
                heart.velocity = 0;
                heart.heartY = p.y - heart.heartSize/2;
                heart.jumping = false;
                jumping_flag = false;
            }

            // remove
            if(p.speed >= 0){
                if(p.x > this.boundary[1]){
                    to_be_remove.add(i);
                }
            }
            else{
                if(p.x + p.width < this.boundary[0]){
                    to_be_remove.add(i);
                }
            }
        }
        if(jumping_flag == true){
            heart.jumping = true;
            heart.speed = ori_heart_speed;
        } 
        for(int idx : to_be_remove){
            this.plats.remove(idx);
        }
    }

}

class plat {
    float width = 50;
    float height = 8;
    float x = 0, y = 0;
    float speed = 3;

    plat(float x, float y, float speed, float width){
        this.x = x;
        this.y = y;
        this.speed = speed;
        this.width = width;
    }

    public void display(float[] boundary){
        float real_width = min(min(this.width, boundary[1] - this.x), this.width + this.x - boundary[0]);
        // white
        fill(color(255, 255, 255, 0));
        stroke(180);
        strokeWeight(1);
        rect(max(this.x, boundary[0]), this.y, real_width, this.height);

        // green
        fill(color(255, 255, 255, 0));
        stroke(0, 65, 0);
        strokeWeight(1);
        rect(max(this.x, boundary[0]), this.y - this.height/2, real_width, this.height);

        this.x += this.speed;
    }
}


  public void settings() { size(600, 500); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Sound_Final" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
